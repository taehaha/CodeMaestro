# ~01.10

스프링 시큐리티를 담당하게 되어 관련된 공부를 했습니다.

## JWT 로컬 로그인 구현 방식 선택

저희는 로그인을 JWT를 사용해서 AccessToken과 RefreshToken을 사용하려고 했습니다.
하지만 조사를 해보니 Spring Security 자체에서 JWT 인증을 지원하지 않아 Filter를 커스텀해서 사용해야 되기 때문에 고민을 많이 했습니다. 따라서 두 가지 방법을 고민했습니다.

1. UsernamePasswordAuthenticationFilter를 재구현

- 이 방법은 아이디와 비밀번호를 기반으로 로그인을 하는 Security가 사용하는 Filter를 재구현해서 JWT를 발급하도록 하는 방법입니다. 하지만 이 방법을 사용하면 로그인을 진행하는 필터와 JWT 토큰을 검증하는 필터를 직접 구현해야 되기 때문에 추후 유지보수가 어려워질 수 있다는 단점이 있습니다.

2. OAuth2 Authorization 서버 구성

- 이 방법은 JWT를 공식적으로 지원하는 OAuth2 Authorization 서버를 구성하는 방법입니다. JWT를 기본적으로 지원하기 때문에 직접 구현할 필요가 없지만, OAuth2 로컬 로그인 구현하는 것 이여서 설정할 것이 많고, OAuth2에 대한 지식이 없기 때문에 구성이 어려웠습니다.

처음에는 유지보수를 우선하여 2번째 방법으로 구현을 진행했지만, 설정에 어려움으로 인해서 첫 번째 방법을 최종적으로 선택하게 되었습니다.

# ~01.14

## Spring Security 구현

UsernamePassowrdAuthenticationFilter를 재구현 하기로 결정한 다음, 유튜브 강의를 보면서 구현을 진행했고, AccessToken과 RefreshToken을 사용하는 로컬 로그인 구현에 성공했습니다.

또한 OAuth2-client 라이브러리를 사용해서 NAVER 로그인 구현에 성공하였고, AccessToken은 Response Header에 넣었고, RefreshToken은 Set-Cookie를 통해 쿠키에 저장 되도록 구현했습니다. 아직 토큰을 반환하는 부분은 고민이 있습니다.

표준은 Authorization 헤더에 Bearer 접두어를 붙혀서 AccessToken을 주는 것 같은데, 서버 측에서도 이런 방식으로 클라이언트에 토큰을 반환해야할지, Json 형식으로 반환을 해야할지, Header와 Cookie를 사용할지 컨설턴트님과 상의를 해보는게 좋을 것 같습니다.

# 01.15

## 세부 기능 확정

컨설턴트님과 01.14 에 미팅을 가지고 나서 팀원들과 전체적인 기능들을 확정하고, 세부기능에 대해서 논의했습니다.

회의를 하면서 이야기만 하다보니 나온 의견들을 정리할 곳이 필요하다고 생각한 황지원 누나가 기능 명세서가 필요할 것 같다고 제안을 해주었고 저도 의견에 공감해 노션에 기능 명세서를 정리하였습니다. 기능 명세서 양식을 정비한 후, 다시 회의를 가져 기능을 확정지었습니다.

## OpenVidu 설정문제

팀원과 같이 OpenVidu를 AWS에 배포하는 것에 머리를 맞대고 진행했습니다. 완전히 새로 EC2를 생성해서 [OpenVidu OnPromise Deployment](https://docs.openvidu.io/en/stable/deployment/ce/on-premises/) 공식문서를 참고해서 진행했고, 결과적으로 정상적으로 접속할 수 있도록 설정을 할 수 있었습니다.

이 과정을 진행하면서 공식문서를 정독하는 것이 얼마나 중요한 일인지 다시한번 깨달았습니다.

OpenVidu 배포에 성공한 뒤 테스트 과정에서 같은 방에 접속을 해도 다른 기기가 접속한 모습이 보이지 않는 문제가 있었지만 AWS에서 InBound 정책에 40000-65535 TCP/UDP 포트를 허용해주니 정상적으로 사용이 가능했습니다.

OpenVidu를 팀원에게 맡겨놓기만 해서 제대로된 내용을 몰랐는데, 채팅, 녹화 등 많은 기능을 제공하는 강력한 플랫폼이라는 것을 알게되었고, 기능과 API에 대해서 문서를 정독해봐야겠다는 생각을 했습니다.
